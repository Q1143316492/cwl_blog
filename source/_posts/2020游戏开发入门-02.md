---
title: 2020游戏开发入门-02(概述+客户端框架封装)
date: 2020-05-31 00:11:24
tags: 
    - 游戏开发
    - Unity3D
categories: 游戏开发
---



[TOC]



# 目录







# 项目概述



- 客户端项目地址：[DTSGameClient](https://github.com/Q1143316492/DTSGameClient)

- 服务端项目地址：[DTSGameServer](https://github.com/Q1143316492/DTSGameServer)



Unity3D + C# +Python 2.7 。服务端框架都是自己写的。啥第三方库都没有。资源文件太大。客户端项目里面是`Assest/script`文件夹下面的代码。完整项目在里面有个云盘链接。

在windows下直接打开客户端。如果有python环境（我测试的时候是py 2.7。理论上3也可以只是我没全面测试）也可以跑起来服务端。然后就可以登入进去玩了。

玩法大概就是登入后在一个匹配房间。点匹配会在服务端的匹配列表里面。人够了就一起丢到一个场景。按吃鸡的规则最后一个活下来的胜利。



# 客户端概述





题外话：



因为没框架用，所以要自己封装。但是我又不知道Unity3D客户端要封装什么。其实刚开始有一种感觉，按照文档说的在Start(), Update() 里面加代码，感觉可以了，又觉得差了点什么。



然后我在全网找 Unity3D框架 的视频和文章。感觉一半在讲UI。。。。emmmmm



当时看了一个视频 [UNITE －*Unity*项目架构设计与开发管理](https://v.qq.com/x/page/d016340mkcu.html) 前辈大概讲了下Unity开发项目结构的演进。



然后下面是之前我自己写的总结：

> 游戏引擎提供的最初始的开发方式是，开发者可以在游戏中的任意物体上挂载脚本。我们把物体的加载，到运行中不停的渲染，到物体的消亡的过程。称之为物体的生命周期。我们可以在每帧调用的Update方法中，编写我们的物体行为，最终构成一个完整的游戏世界。

> 在Unity3D中所有物体被称为GameObject。大多数的引擎都会将GameObject在运行时的引用存储在内存中。用户可以通过引擎所提供的反射机制获得它。在Unity3D中，开发者可以通过引擎提供的Game Object的Find方法根据物体名称或者标记找到它。看似极其方便的功能却有着两个比较明显的缺点。

> 一个是引擎的反射系统很慢。其本质是在运行时对对象用哈希表对其引用做了存储。每次使用的时候都会在这个表查一次。比较的慢。因此通常即使用到它也会在游戏的初始化过程中使用。在游戏的运行时避免多次查找。

> 另一个缺点其实是更致命的。是不利于代码的维护性。以Unity3D为例。引擎希望的开发模式是，开发者重写一个继承自MonoBehaviour 类的子类，重写其生命周期函数。在渲染的各个阶段被调用。一个比较直接的想法是把所有的逻辑都写在脚本的更新方法中。于是乎我们可以想象到一个场景，游戏物体多的时候，他们之间的关系就会变得像蜘蛛网一样。当我们后期需要修改一个业务的时候就有可能造成比较严重的连锁反应。不符合我们软件开发中的业务低耦合原则。

> 其中一个解决思路是在一个空物体上挂在脚本。由这个空物体统筹全局。其他的物体也从这个物体衍生。类似一个主函数的概念。但是逐渐的出于对业务解耦，模块划分的考虑，空物体越来越多，越来越乱。而且物体在跨场景的是否销毁也有可能成为可能的逻辑错误。

> 另一个思路是与单例模式结合。系统首次调用时单例类被构造，而后不随着场景的切换而销毁。通过该模式设计大量管理类。如场景管理类，美术资源管理类，事件订阅发布管理类等。



然后我在客户端项目中建了一个 Engine 文件夹。开发封装。



# 客户端框架封装



## 单例模式和空物体



在C#中使用单例模式，我先写一个泛型类。

```c#
    public class Singleton<T> where T : new()
    {
        private static T instance;
        
        public static T Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new T();
                }
                return instance;
            }
        }
    }
```

这样比如我们需要另一个成为单例类。只需要继承这个基类即可

```c#
public class NetworkMgr : Singleton<NetworkMgr>
{
    。。。
}
```

然后我们就可以在任意需要的地方。调用方法。

```c#
NetworkMgr.Instance.Function()
```



另一个方面是空物体。EngineHandler是我放在初始场景的空物体。加载后设置过场景不删除。详情看客户端代码的EngineHandler.cs



## UI模块的封装



参考资料：

《Unity3D网络游戏实战(第一版) 》《Unity3D网络游戏实战（第2版）》罗培羽。里面有提到PanelBase, PanelMgr的概念

[*Unity*的程序基础*框架*（针对有一定*Unity*基础的学习者）](https://www.bilibili.com/video/BV1C441117wU?from=search&seid=4233398977896397554)  这个视频我当时学的时候还是免费的。。。

前端Vue框架以及Mvvm相关博客



使用的是Unity3D自带的UI。原生的操作方式基本就两种。一种是在可视化面板那边选回调函数。按钮添加点击事件回调。另一种是自己想办法获取对象引用。然后 `xxx按钮.Onclick.AddEventListener(()=>{ ... })`

显然第一种不好维护。代码多了，在一堆组件里面找函数在哪。噩梦。。。。



- PanelBase



所以PanelBase的作用。我让每一个面板（登入面板，组成面板）都挂在一个脚本。这个脚本父类是PanelBase。PanelBase父类是 MonoBehavier。



```c#
	public class PanelBase : MonoBehaviour
    {
        private Dictionary<string, List<UIBehaviour>> controlDict = 
            new Dictionary<string, List<UIBehaviour>>();

        void Awake()
        {
            FindChildrenControl<Button>();
            FindChildrenControl<Image>();
            FindChildrenControl<Text>();
            FindChildrenControl<Toggle>();
            FindChildrenControl<Slider>();
            FindChildrenControl<ScrollRect>();
            FindChildrenControl<InputField>();
            FindChildrenControl<Dropdown>();
        }

        public T GetControl<T>(string name) where T : UIBehaviour
        {
            if (controlDict.ContainsKey(name))
            {
                for (int i = 0; i < controlDict[name].Count; i++)
                {
                    if (controlDict[name][i] is T)
                    {
                        return controlDict[name][i] as T;
                    }
                }
            }
            return null;
        }

        private void FindChildrenControl<T>() where T : UIBehaviour
        {
            T[] controls = GetComponentsInChildren<T>();
            for (int i = 0; i < controls.Length; i++)
            {
                string name = controls[i].gameObject.name;
                if (controlDict.ContainsKey(name))
                {
                    controlDict[name].Add(controls[i]);
                }
                else
                {
                    controlDict.Add(name, new List<UIBehaviour>() { controls[i] });
                }
            }
        }
```

所有UI组件（按钮，输入框，图片等等）都是UIBehaviour的子类。在Awake()的时候。扫描下所有的组件。按组件类型归类。

然后通过组件的名字获取他的引用。（这样也就意味着同一面板下，你想要获得的组件，命名需要是唯一的）

```c#
InputField username = GetControl<InputField>("username");
```



- UIMgr

我们需要一个UI管理类。控制面板的跳转。显示和隐藏。

```c#
public class UIMgr : Singleton<UIMgr> { ... }
```

