---
title: 2020游戏开发入门-02(概述+客户端框架封装).md
date: 2020-05-31 00:11:24
tags: 
    - 游戏开发
    - Unity3D
categories: 游戏开发
---



[TOC]



# 目录







# 项目概述



- 客户端项目地址：[DTSGameClient](https://github.com/Q1143316492/DTSGameClient)

- 服务端项目地址：[DTSGameServer](https://github.com/Q1143316492/DTSGameServer)



Unity3D + C# +Python 2.7 。服务端框架都是自己写的。啥第三方库都没有。资源文件太大。客户端项目里面是`Assest/script`文件夹下面的代码。完整项目在里面有个云盘链接。

在windows下直接打开客户端。如果有python环境（我测试的时候是py 2.7。理论上3也可以只是我没全面测试）也可以跑起来服务端。然后就可以登入进去玩了。

玩法大概就是登入后在一个匹配房间。点匹配会在服务端的匹配列表里面。人够了就一起丢到一个场景。按吃鸡的规则最后一个活下来的胜利。



# 客户端概述





题外话：



因为没框架用，所以要自己封装。但是我又不知道Unity3D客户端要封装什么。其实刚开始有一种感觉，按照文档说的在Start(), Update() 里面加代码，感觉可以了，又觉得差了点什么。



然后我在全网找 Unity3D框架 的视频和文章。感觉一半在讲UI。。。。emmmmm



当时看了一个视频 [UNITE －*Unity*项目架构设计与开发管理](https://v.qq.com/x/page/d016340mkcu.html) 前辈大概讲了下Unity开发项目结构的演进。



然后下面是之前我自己写的总结：

> 游戏引擎提供的最初始的开发方式是，开发者可以在游戏中的任意物体上挂载脚本。我们把物体的加载，到运行中不停的渲染，到物体的消亡的过程。称之为物体的生命周期。我们可以在每帧调用的Update方法中，编写我们的物体行为，最终构成一个完整的游戏世界。

> 在Unity3D中所有物体被称为GameObject。大多数的引擎都会将GameObject在运行时的引用存储在内存中。用户可以通过引擎所提供的反射机制获得它。在Unity3D中，开发者可以通过引擎提供的Game Object的Find方法根据物体名称或者标记找到它。看似极其方便的功能却有着两个比较明显的缺点。

> 一个是引擎的反射系统很慢。其本质是在运行时对对象用哈希表对其引用做了存储。每次使用的时候都会在这个表查一次。比较的慢。因此通常即使用到它也会在游戏的初始化过程中使用。在游戏的运行时避免多次查找。

> 另一个缺点其实是更致命的。是不利于代码的维护性。以Unity3D为例。引擎希望的开发模式是，开发者重写一个继承自MonoBehaviour 类的子类，重写其生命周期函数。在渲染的各个阶段被调用。一个比较直接的想法是把所有的逻辑都写在脚本的更新方法中。于是乎我们可以想象到一个场景，游戏物体多的时候，他们之间的关系就会变得像蜘蛛网一样。当我们后期需要修改一个业务的时候就有可能造成比较严重的连锁反应。不符合我们软件开发中的业务低耦合原则。

> 其中一个解决思路是在一个空物体上挂在脚本。由这个空物体统筹全局。其他的物体也从这个物体衍生。类似一个主函数的概念。但是逐渐的出于对业务解耦，模块划分的考虑，空物体越来越多，越来越乱。而且物体在跨场景的是否销毁也有可能成为可能的逻辑错误。

> 另一个思路是与单例模式结合。系统首次调用时单例类被构造，而后不随着场景的切换而销毁。通过该模式设计大量管理类。如场景管理类，美术资源管理类，事件订阅发布管理类等。



然后我在客户端项目中建了一个 Engine 文件夹。开发封装。



# 客户端框架封装



## 单例模式和空物体



在C#中使用单例模式，我先写一个泛型类。

```c#
    public class Singleton<T> where T : new()
    {
        private static T instance;
        
        public static T Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new T();
                }
                return instance;
            }
        }
    }
```

这样比如我们需要另一个成为单例类。只需要继承这个基类即可

```c#
public class NetworkMgr : Singleton<NetworkMgr>
{
    。。。
}
```

然后我们就可以在任意需要的地方。调用方法。

```c#
NetworkMgr.Instance.Function()
```



另一个方面是空物体。EngineHandler是我放在初始场景的空物体。加载后设置过场景不删除。详情看客户端代码的EngineHandler.cs



## UI模块的封装



参考：

《Unity3D网络游戏实战(第一版) 》《Unity3D网络游戏实战（第2版）》罗培羽。里面有提到PanelBase, PanelMgr的概念